\section{Modification Transfer in Graph Structures}
\label{sec:ModificationTransfer}

Here we introduce a modification-transfer algorithm to transfer layout adjustments from one graph structure to another. 
\added{We define terms in Table~\ref{tab:terms}.}
\replaced{Here, given a source graph structure layout $S=(V^s, E^s)$, user modifications change $S$ into a new layout $S^{\prime}$. And given a target graph structure layout $T=(V^t, E^t)$, we denote the modification transfer as a process of analogizing the modifications ($S \rightarrow S^{\prime}$) to the target graph ($T \rightarrow \tilde{T}^{\prime}$) in three steps:}
{A graph structure is denoted as $G=(V, E)$, where $V=\left\{v_1, v_2, \ldots, v_n\right\}, v_i \in \mathbb{R}^2$ is the positions of a set of $n$ nodes and $E=\left\{e_1, e_2, \ldots, e_m\right\}$ is a set of edges in $G$. Given a source structure $S=(V^s, E^s)$ (Figure~\ref{fig:layoutsimulation}a), user modifications change $S$ into a new layout $S^{\prime}$ (Figure~\ref{fig:layoutsimulation}b). Then, given a target structure $T=(V^t, E^t)$ (Figure~\ref{fig:layoutsimulation}d), we want to change $T=(V^t, E^t)$ with the same modifications. We denote modification transfer as the process of analogizing the modifications, which corresponds to applying the $S \rightarrow S^{\prime}$ modifications to $T$.}
\begin{compactenum}[\textbf{Step} 1]
    \item \added{\textbf{Marker selection}  first aligns $T$ and $S$ with correspondences $C$ generated by the graph-matching method and then selects some finely matched correspondences as markers (Figure~\ref{fig:MT}a).}
    \item \added{\textbf{Layout simulation ($T \stackrel{S}{\longrightarrow} \tilde{T}$)}
    alters the layout of the target from $T$ to $\tilde{T}$ to simulate $S$
    and expands $M$ to $\tilde{M}$ (Figure~\ref{fig:MT}b).}
    \item \added{\textbf{Layout simulation ($\tilde{T} \stackrel{S^{\prime}}{\longrightarrow} \tilde{T}^{\prime}$)}
    %: it 
    alters the layout of the target from $\tilde{T}$ to $\tilde{T}^{\prime}$ to simulate $S^{\prime}$ (Figure~\ref{fig:MT}c).} 
\end{compactenum}
% PJC: should it be deleted?
% JC: this is good. I suggest to keep.
%\textcolor{myred}{
\added{Here, we perform two rounds of layout simulate because $S^{\prime}$ is usually different from $T$, directly deforming $T$ into the shape of $S^{\prime}$ can lead to unpleasing transfers.}
%}

% PJC: does it make sense?
% JC: is the modification okay? It matches the subsections better. 

\begin{table}[!tp]
        \caption{\added[id=pan]{Definition of symbols. Here $G=(V, E)$ denotes a graph with its layout, where $V=\left\{v_1, v_2, \ldots, v_n\right\}, v_i \in \mathbb{R}^2$ contains the positions of a set of $n$ nodes and $E=\left\{e_1, e_2, \ldots, e_m\right\}$ is a set of $m$ edges in $G$.}}
    \centering
    \renewcommand\arraystretch{1.2}
    \begin{tabular}{l|l}
         \hline
         Symbol & Description \\
         \hline
         $S=(V^s, E^s)$ & A source graph layout \\
         $S^{\prime}$ & A modified source graph layout \\
         $T=(V^t, E^t)$ & A target graph layout \\
         $\tilde{T}=(\tilde{V}^t, E^t)$ & The target graph layout that simulates $S$'s layout \\
         $\tilde{T}^{\prime}$ & The target graph layout that simulates $S^{\prime}$'s layout \\
         $M$ & The set of paired markers that matches $V^s$ to $V^t$ \\
         $(m^s_i, m^t_i) \in M$ & A pair of markers where $m^s_i \in V^s$ and $m^t_i \in V^t$ \\
         $C$ & Correspondences between $S$ and $T$ \\
         $(c^s_i, c^t_i) \in C$ & A correspondence pair where $c^s_i \in V^s$ and $c^t_i \in V^t$ \\
         $(v_i[x], v_i[y])$ & The $x$ and $y$ positions of node $i$ \\
         $V(k)$ & Positions of the node set $V$ in the iteration $k$ \\
         $\mathbf{R}$ & A $3 \times 3$ affine transformation matrix \\
         \hline
    \end{tabular}
    \label{tab:terms}
\end{table}

\begin{figure}[!t]
    \centering
    \includegraphics[width=\columnwidth]{picture/MT}
    \caption{\added[id=pan]{Modification transfer. (a) Marker selection: aligning layouts of target $T$ and source $S$ first, and then selecting a set of markers $M$ from given correspondences $C$ between $S$ and $T$; (b) the first round of layout simulation: altering the layout $T$ to simulate $S$, which produces a new target structure layout $\tilde{T}$ and expands $M$ to $\tilde{M}$; (c) the second round of layout simulation: altering the layout $\tilde{T}$ to simulate $S^{\prime}$, which produces $\tilde{T}^{\prime}$.}}
    \label{fig:MT}
\end{figure}

\subsection {\added[id=pan]{Marker Selection}}

\added[id=pan]{The modification transfer algorithm relies on the correspondences between two structures, denoted as $C=\{(c^s_i, c^t_i)\}, 1 \leq i \leq \min(|V^s|, |V^t|)$.
Any graph-matching method that produces injective correspondences is suitable for modification transfer.
Six graph-matching methods~\cite{cho2010reweighted, cour2007balanced, gold1996graduated, leordeanu2005spectral, zass2008probabilistic, zhou2012factorized}
are examined (see Suppl. Material\footnote{https://zjuvag.org/publications/exemplar-based-fine-tuning/} and Section~\ref{sec:quancomp} for comparison details). We employ Factorized Graph Matching (FGMU)~\cite{zhou2012factorized} because it achieves the best efficiency.}

Because graph-matching methods may depend on the graph layout, we layout the exemplar and target substructures with the same algorithm before constructing correspondences. 
We employ FM$^3$~\cite{hachul2004drawing} \added{because it is one of the most efficient layout algorithms
to our knowledge.}
The graph-matching methods can generate unpleasant
matching results because these methods build correspondences for all nodes even if they are not well matched.
\added{To examine their correspondences, we first align two graph structures $S$ and $T$ 
%JC
%are first aligned 
according to the correspondences
%. The \textbf{aligning} procedure is 
(described in Section~\ref{sec:layoutsimulation}). 
If the graph-matching method generates correct correspondences,
we align two corresponding nodes 
%will be aligned 
together in the aligning step and almost all of their neighborhoods can possibly be matched. Thus, we implement
the correspondences filtering algorithm (Algorithm~\ref{alg:corrselection}) to select ``fine'' correspondences ($(c^s_i, c^t_i)$) that satisfy:}
\begin{compactenum}[1)]
    \item \added[id=pan]{The distance between $c^s_i$ and $c^t_i$ is less than the average length of their adjacent edges multiplied by a given ratio ($r_d$); and}
    \item \added[id=pan]{ $c^s_i$'s neighbors are mostly matched to $c^t_i$'s neighbors (with a ratio greater than $r_u$).}
\end{compactenum}
\added[id=pan]{
We fix $r_d$ and $r_u$ to be $2$ and $0.5$ in our implementation. A smaller $r_d$ and a larger $r_u$ lead to fewer, possibly more accurate correspondences. There is a trade-off between accuracy and number of correspondences.
Here, we use these ``fine'' correspondences as a set of markers $M$ for the layout simulation. 
In addition, 
our approach also supports specifying markers manually to match user preferences. 
The user can click on two nodes, one in each of the exemplar and target substructures, to specify a pair of markers. }


\begin{algorithm}[!t]
    \renewcommand\arraystretch{1.2}
    \caption{ Correspondences filtering }
    \label{alg:corrselection}
    \begin{algorithmic}[1]
      \Require
        $S=(V^s, E^s)$: a source graph;
        $T=(V^t, E^t)$: a target graph;
        $C=\left\{(c^s_i, c^t_i)\right\}$: a set of correspondences;
        $r_u$: a minimum common neighbors ratio;
        $r_d$: a maximum distance ratio;
      \Ensure
      $M=\left\{(m^s_i, m^t_i)\right\}$: a set of markers;
      \State Init markers $M=\varnothing$ \label{code:initmarker}
      \For {each correspondence pair $(c^s_i, c^t_i)$}
        \State $ns \gets c^s_i$'s neighbors' corresponding nodes
        \State $nt \gets c^t_i$'s neighbors
        \State $nu \gets ns \bigcap nt$
        \If {$Count(nu) > Count(ns) \times r_u$ \textbf{or} $Count(nu) > Count(nt) \times r_u$}
            \State $ds \gets$ the mean length of adjacent edges of $c^s_i$
            \State $dt \gets$ the mean length of adjacent edges of $c^t_i$
            \State $d \gets$ distance between $c^s_i$ and $c^t_i$
            \If {$d < ds \times r_d$ \textbf{and} $d < dt \times r_d$}
                \State Add $(c^s_i, c^t_i)$ into $M$
            \EndIf
        \EndIf
      \EndFor
      \State \Return $M$;
    \end{algorithmic}
\end{algorithm}

\subsection {\added[id=pan]{Layout Simulation}} \label{sec:layoutsimulation}
\added[id=pan]{
The goal of the layout simulation is to smoothly deform the markers of the target $T$ to those of the source $S$, while preserving the original layout of the target $T$ as much as possible (Figure~\ref{fig:layoutsimulation}).
%JC - your figure 6 showed three rounds, not two. 
% We run the layout simulations iteratively.
% Two rounds of layout simulations are performed in tandem. 
% First, we alter the shape of $T$ to simulate $S$ using the marker set $M$ produced in the correspondence filtering step
%JC. Note you never referenced Figure 6 a-c. Figure 5 is cited in the beginning of Section 4. So you are repeating yourself here??
% PJC: Yes, you are right, please revise it. I repeated myself here. It is same to the overview. 
% PJC: I think we only need to say that why we need two rounds of layout simulation (Figure 5b and Figure 5c in the pipeline)
% JC: I agree. Let me add it. Your Figure 6 has three rounds  - this is confusing.  
% PJC: three rounds means that in each round of layout simulation, we may need to repeat the deforming step and matching step.
% (Figure~\ref{fig:MT}b).
% PJC: it is right; 
%(Figure~\ref{fig:layoutsimulation}a-b). % PJC: its not right
% This generates a new layout $\tilde{T}$ for the target graph structure $T$. At the same time, $M$ is expanded to a new marker set $\tilde{M}$. Second, $\tilde{T}$ is altered to simulate the shape of $S^{\prime}$ using $\tilde{M}$
%(Figure~\ref{fig:MT}c). 
% (Figure~\ref{fig:layoutsimulation}c).
%Directly deforming $T$ into the shape of $S^{\prime}$ can lead to unpleasing transfers because $S^{\prime}$ is usually quite different from $T$. 
%Here, for convenience, we describe only the first round of layout simulation ($T \stackrel{S}{\longrightarrow} \tilde{T}$) in detail. The second round is the same.
}
% PJC: deleted Directly deforming $T$ into the shape of $S^{\prime}$ can lead to unpleasing transfers because $S^{\prime}$ is usually quite different from $T$.
%JC
We do this in three steps:
\textit{aligning}, \textit{deforming}, and \textit{matching}. The aligning step scales, rotates, and translates $T$ to minimize the dissimilarity to $S$ (Figure~\ref{fig:layoutsimulation}d). The deforming step alters the node positions of $T$ to simulate the shape of $S$ (Figure~\ref{fig:layoutsimulation}e). The matching step constructs correspondences between the nodes of $T$ and $S$ by searching their neighbors (Figure~\ref{fig:layoutsimulation}f). 
% JC. please check.
%These steps are processed iteratively 
These steps iteratively deform $T$ into the shape of \replaced[id=pan]{$S$}{$S^{\prime}$} until no more new correspondences are constructed. 
\deleted[id=pan]{In practice, the process is performed to alter $T$ to simulate the shape of $S$ first  (Figures~\ref{fig:layoutsimulation} (e, f, and g)) and then to simulate $S^{\prime}$ (Figures~\ref{fig:layoutsimulation} (h, i, and j)). Directly deforming $T$ into the shape of $S^{\prime}$ can lead to unpleasing transferring (Figure~\ref{fig:layoutsimulation}k) because $S^{\prime}$ is usually quite different with $T$.}


\begin{figure}[t]
    \centering
    \includegraphics[width=1\columnwidth]{picture/layoutsimulation}
    \setlength{\belowcaptionskip}{-10pt}
    \caption{\added[id=pan]{Layout simulation: altering the shape of a target structure $T$ to simulate the layout of a source structure $S$. (a) a source structure $S$; (b) a target structure $T$; (c) a set of markers $M$; (d) aligning $T$ to $S$ with markers $M$; (e) deforming $T$ into $S$ with markers $M$; (f) matching the nodes of $T$ to the nodes of $S$; two pairs of markers are constructed: \{(2,B) and (5,D)\}; (g) the second round of deforming and matching; two marker pairs are constructed: \{(7,F) and (9,H)\}; (h) the third round of deforming and matching, one pair of markers is constructed: \{(8,G)\}; Iterations are performed until no more new correspondences are built.}}
    \label{fig:layoutsimulation}
\end{figure}

\textbf{Aligning.}
We assume that both the topology and the
layout of the source structure 
are similar to the target. 
% JC. please check.
%are supposed to be 
% similar to the target as well as their layouts. 
To minimize the layout difference, the node-link diagrams of $S$ and $T$ %should be 
are
aligned. 
\added[id=pan]{This step only transforms the global location and orientation of the target structure, 
%JC. please check to make sure I did not change the meaning.
%but it does not change 
not
the %shape (i.e., 
positions of individual nodes.
%).
}

We use a small set of predefined markers to achieve an optimal alignment. 
The markers are a set of paired nodes $M = \left\{(m^s_i, m^t_i)\right\}, m^s_i \in V^s, m^t_i \in V^t$ (Figure~\ref{fig:layoutsimulation}c). The markers on the source and the target are aligned by an affine transformation $\mathbf{R}$:
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    \mathbf{R} = scale \times \left(\begin{array}{ccc}
        \cos \theta & \sin \theta & tx \\
        -\sin \theta & \cos \theta & ty \\
        0 & 0 & 1
        \end{array}\right) \approx \left(\begin{array}{ccc}
        s & h & tx \\
        -h & s & ty \\
        0 & 0 & 1
        \end{array}\right) \label{eq:transformation}
\end{equation}
where $scale$ is the scale coefficient, $\theta$ is the rotation angle, and $tx$ and $ty$ are the translation components. For the sake of simplicity, we use a linear approximation of $\mathbf{R}$ (after the approximately equal sign).
$\mathbf{R}$ is calculated by solving the minimization problem:
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    \min_{\mathbf{R}} \sum_{i}^{|M|} ||\mathbf{R} m^{t}_i  - m^{s}_i ||^2,
\end{equation}
where $(m^t_i, m^s_i) \in M$ denotes one pair of markers.
The minimization problem is equivalent to the problem:
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    \min_{\mathbf{T}} \sum_{M} ||\mathbf{A} (s, h, tx, ty)^T - \mathbf{b} ||^2,
\end{equation}
where $\mathbf{A}$ contains the positions of the markers in the target and $\mathbf{b}$ contains the positions of the markers in the source:
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    \mathbf{A} = \left(\begin{array}{llll}
    {m^t_i}[x] & {m^t_i}[y] & 1 & 0 \\
    {m^t_i}[y] & -{m^t_i}[x] & 0 & 1 \\
    \vdots
    \end{array}\right), \mathbf{b} = \left(\begin{array}{c}
        {m^s_i}[x] \\
        {m^s_i}[y] \\
        \vdots
    \end{array}\right), i=1,\ldots,|M|.
\end{equation}
${m^t_i}[x]$ and ${m^t_i}[y]$ are the positions of the target marker $m^t_i$ and ${m^s_i}[x]$ and ${m^s_i}[y]$ are the positions of the source marker $m^s_i$. The minimization problem can be solved by:
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    (s, h, tx, ty)^T = \mathbf{A}^\dagger \mathbf{b} \label{eq:pseudoinverse},
\end{equation}
where $\mathbf{A}^\dagger$ is the Moore-Penrose pseudoinverse~\cite{moore1920reciprocal} of $\mathbf{A}$. Thus, the transformation can be defined as a linear function of the markers in the source.
With the affine transformation matrix $\mathbf{R}$, $T$ is transformed to align $S$ by a linear transformation (Figure~\ref{fig:layoutsimulation}d). \added[id=pan]{After modification transfer, the target layout is restored by an inverse process of the alignment step, so that it can be merged into the entire layout with the original rotation and scale.}

\textbf{Deforming.}
\deleted[id=pan]{
Although the global location and orientation of the target structure is transformed after alignment, its shape (i.e., positions of individual nodes) is unchanged.} \added[id=pan]{The deforming step seeks to alter the shape of $T$ to simulate $S$. We design an energy function to represent the process:}
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    \added[id=pan]{E = E_S + \gamma E_M},
\end{equation}
\replaced[id=pan]{where $\gamma$ is a weight parameter. The deforming step is equivalent to minimizing $E$. It seeks to force positions of target markers $m^t_i$ to approach source markers $m^s_i$ ($E_M$) while preserving the original layout information to reach a smooth deformation ($E_S$). Here, we denote $E_M$ as the sum of distances between pairs of markers:}{$T$ is deformed to simulate the shape of $S$ by forcing the target markers $m^t_i$ to approach $m^s_i$:} 
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    E_{M} = \sum_{i}^{|M|}||{m^t_i}-{m^s_i}||^{2}.
\end{equation}


\replaced[id=pan]{$E_S$ represents the layout change between $T$ and $\tilde{T}$, which is constructed by two items: }{To get a smooth deformation, relative positions of each node pair in the target should be preserved. Thus, other target nodes are also translated for achieving smoothness. We define the energy function of the smoothness as:}
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    E_S = \alpha E_O + \beta E_D, \label{eq:smoothness}
\end{equation}
where $\alpha$ and $\beta$ are two weights, \replaced[id=pan]{$E_O$ is designed to preserve orientations of vectors between node pairs after the aligning step, and $E_D$ is designed to preserve distances between node pairs.}{and} $E_O$ is defined as:
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    E_O = \sum_{i<j} w_{i j} || norm(v^t_i - v^t_j) - norm(\tilde{v}^t_i - \tilde{v}^t_j)||^2.
\end{equation}
Here, $norm(\cdot)$ denotes the normalization of a vector. $E_D$ is defined as:
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    E_{D} = \sum_{i<j} w_{i j} (|| v^t_i - v^t_j || - || \tilde{v}^t_i - \tilde{v}^t_j ||)^2,
\end{equation}
where $w_{i j}$ is the weight related to the node pair $(v^t_i, v^t_j)$, and $(\tilde{v}^t_i, \tilde{v}^t_j)$ is a node pair of the target structure after deformation ($\tilde{T}$).
$w_{i j}$ is defined as:
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    w_{i j}=\left\{\begin{array}{ll}
    w ||v^t_i - v^t_j||^{-2}, & \text { if } \left\{i, j\right\} \in E^t \\
    ||v^t_i - v^t_j||^{-2}, & \text { otherwise }
\end{array}\right., \label{eq:weight}
\end{equation}
where $w$ is a preservation degree on the edges. 
\added[id=pan]{
Setting $w$ greater than $1$ makes the algorithm pay more attention to preserve orientations and length of edges.
}

\deleted[id=pan]{$E_O$ and $E_D$ are designed to preserve the orientations and the lengths of vectors that link the node pairs in the target respectively.} Preferences on preservation of distances and orientations can be configured by balancing $\alpha$ and $\beta$. For example, when $\alpha$ is small, \replaced[id=pan]{the distances between node pairs}{the lengths of vectors} can be mostly preserved (Figure~\ref{fig:alphabeta}b). If we enlarge $\alpha$, the orientations can be better preserved (Figure~\ref{fig:alphabeta}c). Both weighting schemes are optional.
\added[id=pan]{The parameter $\gamma$ is used to configure the weight of moving marker positions in the target structure to their counterparts. A large $\gamma$ ensures that markers of $S$ and $T$ can be aligned.}

\begin{figure}[t!p]
    \centering
    \setlength{\belowcaptionskip}{-5pt}
    \includegraphics[width=1\columnwidth]{picture/alphabeta}
    \caption{Different weighting schemes. The node $v_2$ is moved to a higher position while nodes $v_0$ and $v_4$ are fixed in their original positions. (a) is the original layout. (b) is the layout that preserves the distances with $\alpha=0, \beta=1$, and $\gamma=100$. (c) is the layout that keeps both orientations and distances with $\alpha=1, \beta=1$, and $\gamma=100$.}
    \label{fig:alphabeta}
\end{figure}

\deleted[id=pan]{The deforming step seeks to solve the minimization problem:
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    \min_{\tilde{v}^t} (E_S + \gamma E_M), \label{eq:deforming}
\end{equation}
where $\gamma$ is a weight. Setting $\gamma$ to be large adequately can fix the target markers' positions at their counterparts.}

\deleted[id=pan]{Optimizing Equation~\ref{eq:deforming} is identical to moving target markers' positions to their counterparts in the source while preserving the smoothness.} Following the optimization process in the stress majorization technique~\cite{DBLP:conf/gd/GansnerKN04}, $E_O$ and $E_D$ can be minimized by iteratively solving:
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    L_{w}^{V^t(k)} V^t(k+1) = L_{w}^{V^t} V^t,
\end{equation}
and 
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    L_{w} V^t(k+1) = L_{w}^{V^t(k)} V^t(k),
\end{equation}
where $V^{t}(k)$ and $V^{t}(k+1)$ are the target nodes in time $k$ and $k + 1$. $L_w$ and $L_{w}^{V^t}$ are two weighted Laplacian matrices defined as:
\begin{equation}
    \setlength{\abovedisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{5pt}
    \setlength{\belowdisplayshortskip}{5pt}
    \setlength{\belowdisplayskip}{5pt}
    \begin{aligned}
        (L_{w}^{V^t})_{i j} &= \left\{\begin{array}{ll}
            - w_{i j} inv(||V^t_i - V^t_j||), & i \neq j \\
            \sum_{l \neq i} (L_{w}^{V^t})_{i l}, & i = j \\
        \end{array}\right. \\
        (L_{w})_{i j} &= \left\{\begin{array}{ll}
            - w_{i j}, & i \neq j \\
            \sum_{l \neq i} w_{i l}, & i = j \\
        \end{array}\right.,
    \end{aligned}
\end{equation}
and the definition of $L_{w}^{V^t(k)}$ is similar to $L_{w}^{V^t}$ except that $v^t_i$ and $v^t_j$ are replaced by their counterparts in time $k$. The process is repeated until the target layout stabilizes.

\textbf{Matching.}
The matching step constructs node correspondences between $S$ and $T$.
\replaced[id=pan]{Any node pair $(v^s_i, \tilde{v}^t_j), i \leq |V^s|, j \leq |\tilde{V}^t|$ that satisfies $|| v^s_i - \tilde{v}^t_j || < r_j$ is identified as one candidate correspondence.}{
For each node $\tilde{v}^t_i$ in $\tilde{T}$, nodes in the source subject to $||v^s_j - \tilde{v}^t_i|| < r_i$ are identified as its candidate nodes (Figure~\ref{fig:layoutsimulation}f).}  \replaced[id=pan]{We consider that $r_j$ should be adaptive to different $\tilde{v}^t_j$, and thus, we associate $r_j$ to the mean length of $\tilde{v}^t_j$'s adjacent edges. By default}{In practice}, $r_j$ is set to be twice the mean length of the adjacent edges \added[id=pan]{to avoid filtering out too many candidate node pairs}.
To avoid overlapping, \replaced[id=pan]{correspondences should be injective.}{only one corresponding node is identified for a source node $v^s_j$.} This maximum assignment problem can be solved by the Hungarian algorithm~\cite{kuhn1955hungarian, kuhn1956variants}. \added[id=pan]{Here, we use distances between node pairs as the cost in the Hungarian algorithm.}

% \begin{figure}[!tp]
%     \centering
%     \setlength{\belowcaptionskip}{-10pt}
%     \includegraphics[width=1\columnwidth]{picture/modtran-example}
%     \caption{\added[id=pan]{\highlight{An illustration of iterations in layout simulation. Markers are in white.} (a) The first round of deforming $T$ into $S$ with three pairs of markers :(1,A), (3,C), and (6,E); (b) The first round of matching $T$ to $S$, two pairs of markers are constructed: (2,B) and (5,D); (c) and (d) The second round of deforming and matching, two pairs of markers are constructed: (7,F) and (9,H); (e) and (f) The third round of deforming and matching, one pair of markers is constructed: (8,G).}}
%     \label{fig:modtran-example}
% \end{figure}

Adequate correspondences can yield accurate modification transfer.
Thus, the \textit{aligning}, \textit{deforming}, and \textit{matching} steps are iteratively performed by using the already-built correspondences or markers. 
For example, Figures~\ref{fig:layoutsimulation}(e-f) show the first round of deformation. With three markers, the target can not faithfully mimic the shape of the source. Additional correspondences are constructed by searching neighbors (Figure~\ref{fig:layoutsimulation}f). Two more \textit{deforming} and \textit{matching} rounds improve the accuracy (Figures~\ref{fig:layoutsimulation}(g-h)). The iteration stops until the number of correspondences
no longer increases. 
$\tilde{T}$ is often similar to $S$ after deformation (Figure~\ref{fig:layoutsimulation}h). After that, layout simulation is performed again to alter the deformed target $\tilde{T}$ into the modified source $S^{\prime}$ (Figure~\ref{fig:MT}c).


% JC: no, no need.. this is the same as 2. everyone understand what your algorithm does here.
% PJC: OK I agree, but we should mention that there is still another round. 
% JC: I am adding it. The writing is somewhat confusing.