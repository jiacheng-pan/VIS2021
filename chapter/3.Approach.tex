\section{\ApproachName}
%! overview
\colorbox{text-highlight}{TO DO}

\subsection{Graph Wrangling}
% 从表格型数据创建图数据时，最重要的就是建立节点之间的关系。
% 观众从节点链接图中所能获知的信息仅仅是某两个节点之间存在联系，但却不了解联系的内在含义。
% 一些论文已经对可能建立链接的情况进行了定义，
Several techniques~\cite{DBLP:journals/ivs/LiuNS14, DBLP:journals/ivs/HeerP14, DBLP:journals/tvcg/SrinivasanPEB18} about graph wrangling identify link construction as the crucial process and propose several linking conditions.
Ploceus~\cite{DBLP:journals/ivs/LiuNS14} and Orion~\cite{DBLP:journals/ivs/HeerP14} infer potential linking conditions by first constructing a linking graph and then searching valid linking paths. They are aimed at constructing links among multiple data tables by analyzing primary keys and foreign keys.
Graphiti~\cite{DBLP:journals/tvcg/SrinivasanPEB18} identifies potential linking conditions of a homogeneous graph by comparing different attributes.
% 如果多个表合并成一个表，前两者总结的条件可以被Graphiti提出的规则所覆盖
Because multiple tables can be merged into one data table with primary keys and foreign keys, Graphiti can cover the linking conditions identifying rules proposed by Ploceus and Orion. %? 这里mayby要用一张图解释一下
We reorganize the conditions proposed by these techniques into four categories:
\begin{compactenum}[\textbf{Cond.} 1.]
    \item Two nodes share a same value of a same attribute, e.g., linking two movies is published in the same year.
    \item Two nodes share at least one same common value of a same list attribute, e.g., linking two movies with one or more same actors.
    \item Two nodes share significantly close value of a same attribute where the significance is defined by the normalized difference.
    \item Two nodes share two values in the same bin of a same attribute where the bins are defined as quartiles.
\end{compactenum}
Hear, we regard sharing same topics of textual attributes as same as sharing same values of list attributes (Condition 2), because topics are often presented as a list attribute.

% 我们尝试从它们的反方向进行思考，也就是，当我们获取到了所有的链接的时候，推测这些链接是如何被构建的
Those works infer the potential linking conditions before all links are constructed. 
Whereas, our method runs in the opposite direction where all links have been constructed already.
% 针对某一条链接，可能有不止一种构建条件，我们取所有链接的构建条件的交集作为整个graph的构建条件。
We traverse all links to detect potential conditions for each link.
The intersection of all links' conditions are regarded as the entire graph's linking condition.

% 为了能够将这些condition填充到文本模板中，我们对condition的输出进行了formalize
At last, we formalize the condition as three aspects, and textualize the linking condition of the graph by filling templates. 
One condition can be defined as:
\begin{equation}
    linking\text{ }condition := ( type, attribute, value )
\end{equation}
Four templates corresponds to four conditions according the $type$:

\begin{compactenum}[\textbf{Cond.} 1.]
    \item ``Two nodes are connected if their attributes $ \$\{ attribute \} $ are with a same value$\$\{: value ?\}$''.
    \item ``Two nodes are connected if their attributes $ \$\{ attribute \} $ share an intersection$\$\{: value ?\}$''.
    \item ``Two nodes are connected if their attribute $ \$\{ attribute \} $ are close, maybe with a difference less than $\$\{ value \}$''.
    \item ``Two nodes are connected if their attribute $ \$\{ attribute \} $ are within the same $\$\{ value ?\}$ bin''.
\end{compactenum}

Where $ \$\{ attribute \} $ is the name of the attribute, $ \$\{ value \} $ is the value of the attribute, and $?$ means the included part is optional. 
For example, for Condition 2, two movies are connected because they share same actors Alice and Bob. 
The condition is represented as: $(\text{``Condition 2''}, \text{``actors''}, [\text{``Alice''}, \text{``Bob''}])$. 
Its corresponding statement is: ``Two nodes are connected if their attributes ``actors'' share an intersection: [``Alice'', ``Bob'']''. 
And there is an implication relation between conditions.
Some conditions are stronger than others.
For example, the condition $(\text{``Condition 2''}, \text{``actors''}, [\text{``Alice''}, \text{``Bob''}])$ is stronger than $(\text{``Condition 2''}, \text{``actors''}, [\text{``Alice''}])$ and $(\text{``Condition 2''}, \text{``actors''}, [arbitrary\text{ }value])$.
All the three conditions are regarded as individual conditions.

If a linking condition exists on both nodes with links and nodes without any link, it is regarded as a false condition and should be filtered out.
We describe our filtering strategy in~\ref{alg:conditions}.
After that, conditions are sorted, so that the highest ranked condition will be regard as the most possible condition.
First, all conditions are sorted by their frequency.
% 相同频率的条件，如果他们的type和attribute相同，那么根据
If two conditions with the same frequency have the same $type$ and $attribute$, they can be compared by their degree.
More stronger conditions are ranked higher than others.


% 一条边可能包含多个条件，不同边的条件之间可能有交集，可能没有交集。
% 我们需要一个策略来得到一个关于节点之间如何构建出关系的结论。
%! 解释一下算法
% 首先，对于所有没有边的节点对，找出所有可能的构建条件。
% 其次，对于某条边，它的构建条件和上述的构建条件之间找出差集。
% 最后，所有边的条件的合集属于边的构建条件；其中 频率最高的将被拿出来。



\begin{algorithm}[!t]
    \renewcommand\arraystretch{1.2}
    \caption{ Conditions filtering }
    \label{alg:conditions}
    \begin{algorithmic}[1]
        \Require
            $G=(V=\{v_1, v_2, ..., v_n\}, E=\{e_1, e_2, ..., e_n\})$: a graph;
        \Ensure
            $C$: conditions
        \State Init conditions $C=\varnothing$, false conditions $FC=\varnothing$
        \For {each node pair $(v_i, v_j)$}
            \If {$(v_i, v_j)$ is not a link}
                \State $C_{tmp} \gets$ all conditions that can link $(v_i, v_j)$
                \State merge $FC$ with $C_{tmp}$
            \EndIf
        \EndFor
        \For {each link $e_i$}
            \State $C_{tmp} \gets$ all conditions that can construct link $e_i$
            \For {each condition $c$ in $C_{tmp}$}
                \If {$c$ in $FC$}
                    \State remove $c$ from $C_{tmp}$
                \EndIf
            \EndFor
            \State merge $C$ with $C_{tmp}$
        \EndFor
        \State \Return $C$
    \end{algorithmic}
\end{algorithm}


\subsection{Visual Encoding}
\subsubsection{Background}
% 为了在节点链接图中展示节点、链接的属性，常常将这些属性编码为节点/链接的视觉通道。
To visualize attributes of nodes and links in node-link diagrams, creators often encode them with visual channels on nodes and links.
For the node-link diagram example in Figure~\ref{fig:VisualEncodings}, a node contains a categorical attribute (\textit{x}) and a numerical list attribute (\textit{y}), we encode the numerical list attribute with two rectangles' height and encode the categorical attribute with two rectangles' fill color and the background rounded rectangles's stroke color.
We denote graphical elements (e.g., \texttt{<circle>}, \texttt{<rect>}, \texttt{<ellipse>}, etc.) in node-link diagrams as \textit{visual primitives} and their style attributes such as \texttt{cx}, \texttt{cy}, \texttt{width}, and \texttt{height} are denoted as \textit{visual channels}.
Nodes and links contained in the underlying graph are denoted as \textit{data entities} and each data entity consists of several \textit{attributes}.

\begin{figure}
    \centering
    \includegraphics[width=1\columnwidth]{figures/VisualEncodings.eps}
    \caption{An example shows the workflow of our visual encoding extracting technique. A node-link diagram consists of three nodes and three links (upper right corner). Node primitives are extracted and the \textbf {data binding} step binds them to different nodes. Then primitives with same role across different nodes are aligned into the same role class in the \textbf{primitives aligning} step. Mappings among different role calsses, visual channels, and attributes are detected by the \textbf{encoding mapping} step.}
    \label{fig:VisualEncodings}
\end{figure}

% 我们的工作通过分析源代码，从中提取数据实体（）是如何被编码为视觉通道的（）
We formulate the description of visual encodings in node-link diagrams by three questions:
\begin{compactenum}[\textbf{Q}1]
    \item \textit{What primitives does a node/link consists of in the diagram?} e.g., a node is composed of two circles, or two rectangles. \label{qstn:composition}
    
    \item \textit{What attributes do primitives and their visual channels encode?} e.g., the radius of a circle encodes the degree of one node and the fill color of the circle encodes the node's type. If the shape (\texttt{tagName}) of a primitive encodes some attribute, we should classify and discuss when primitives are encoded into different shapes (e.g., when the node is encoded into a circle, the radius encodes its degree, and when the node is encoded into a rect, the width and the height encode its degree). \label{qstn:encodings}
    
    \item \textit{Whether there is a certern type of correlation (positive, negative, or categorical) between attributes and visual channels?} e.g., The greater the degree of the node, the greater the radius of the circle.\label{qstn:correlation}
\end{compactenum}
Thus, extracting mappings between entities and primitives and mappings between attributes and visual channels are necessary (Figure~\ref{fig:PrimitiveAligning} (a)).


\begin{figure}
    \centering
    \includegraphics[width=1\columnwidth]{figures/PrimitiveAligning.eps}
    \caption{(a) the target of our visual encoding detection technique; and (b) the effect of the data binding step and the primitives aligning step.}
    \label{fig:PrimitiveAligning}
\end{figure}

% xxxx 等人的工作为我们提供了一个良好的思路，但他们的工作存在一些限制
A tool proposed by Harper and Agrawala~\cite{DBLP:conf/uist/HarperA14} provides a creative perspective for visual encoding extraction.
Although their tool can be extended to support simple node-link diagrams (where each data entity is encoded into only one primitive), it has several limitations:
\begin{compactenum}

% 1. 其需要创作者使用d3的数据绑定，才能发挥__data__的作用；使用其他工具，或者未将数据绑定到元素上时则无法使用该方法；
\item The data binding feature of D3 is required within the tool such that the ``\textit{\_\_data\_\_}'' attribute of visual primitives can be acquired by it. 
It cannot deal with SVG-format visualizations created by other tools or without data bound to visual primitives.

% 2. 其只能检验属性和视觉通道之间是否存在线性映射或者类别性映射。
\item Only the linear mapping and categorical mapping are supported, it cannot maintain situations where visual mappings are complex.

\end{compactenum}

% 我们针对节点链接图的场景，提出了一个数据绑定的策略，通过不断调整输入的数据，检查输出的变化，从而获取数据到svg元素之间的映射关系以及属性到视觉通道之间的映射方式，以解决以上两个问题。
For node-link diagrams, we introduce a new technique to solve such limitations.
The main idea of our technique is regarding the source code as a black box model.
Our technique obtains mappings between data entities and visual primitives by detecting changes of the output SVG after modifying the input graph data.
It overcomes the limitations by three steps (Figure~\ref{fig:VisualEncodings}):
(1) \textbf{Data binding} classifies all primitives into different data entities.
(2) \textbf{Primitives aligning} aligns primitives with the same role into one role class. 
(3) \textbf{Encoding mapping} detects visual mappings between attributes, role classes, and their visual channels.

\subsubsection{Data Binding} \label{sec:databinding}

To detect mappings between data entities and visual primitives, 
we modify attribute values of data entities and record corresponding visual primitive changes.
Mappings between the entity and the changed primitives are hence constructed.
However, modifying attributes deforms the attribute distribution, which may influence visual mappings, so that primitives related to other data entities may also change.
For example, modifying attributes may expand the data range and thus changes linear mappings defined by attribute ranges.
We prevent it by only swapping attributes of two entities rather than modifying them, such that no new data is introduced and the data distribution is preserved.
We take nodes for example.
Each node will be swapped with all the other nodes.
Primitives changed by each swapping correspond to two swapped nodes (Figure~\ref{fig:DataBinding} (b) and (c)).
For example, after swapping nodes B and C in Figure~\ref{fig:DataBinding} (b), primitives 1 to 4 are changed.
All these changed primitives correspond to nodes B and C, because only B and C are swapped.
After swapping one node with all the other nodes, we construct mappings between the node and primitives which are changed more than once.
For example, after swapping nodes B with C and D in Figure~\ref{fig:DataBinding} (b) and (c), primitives 2 and 3 are changed twice, thus they correspond to node B (Figure~\ref{fig:DataBinding} (d)).
After swapping all nodes, the entire node-primitive mappings are constructed.
Mappings between Links with their primitives are constructed in the same.
Because swapping two nodes may influence their related links, nodes' related primitives can contain links' primitives,
we remove links' primitives from the node-primitive mappings.


\begin{figure}
    \centering
    \includegraphics[width=1\columnwidth]{figures/DataBinding.eps}
    \caption{Data binding is achieved by swapping attributes of data entities. (a) Visual mappings between original visual primitives and data entities are unknown. (b) After swapping attributes of entities B and C, the appearance of primitives 1 to 4 is changed. Thus, entities B and C correspond to primitives 1 to 4. (c) After swapping attributes of entities A and B, the appearance of primitives 2, 3, 7, and 8 is changed. Thus, entities A and B correspond to these primitives. (d) After swapping B with A and C, primitives 2 and 3 are changed twice, we can map the entity B to primitives 2 and 3.}
    \label{fig:DataBinding}
\end{figure}

\subsubsection{Primitives aligning}
% Different primitives are aligned according to their roles (the vertical direction in Figure~\ref{fig:PrimitiveAligning} (a)).
The data binding step only classifies visual primitives into different data entities (the horizontal direction in Figure~\ref{fig:PrimitiveAligning} (b)).
Different primitives in one data entity have different roles.
For the example in Figure~\ref{fig:VisualEncodings}, although both of the two inner rectangles are affected the attribute \textit{y}, they mean differently to the entire node (the left one encodes the first item in attribute \textit{y} and the right one encodes the second).
Whereas, the left rectangles across different nodes mean consistently to their own nodes.
They should be aligned to clarify their roles (the vertical direction in Figure~\ref{fig:PrimitiveAligning} (b)).
The \textit{role} can be regarded as a function that takes data attributes as input and assign values for visual primitive channels.
Primitives within the same role should appear exactly the same when their own nodes have exactly same attributes.
Such a judgment of role consistency between two primitives can be incidentally completed in the data binding step.
Because we totally swap all the attributes of two entities, we can examine the consistency of primitives before and after swapping.
For example, in Figure~\ref{fig:DataBinding} (b), after swapping entities B and C,primitive 1 appear same to primitive 2 before swapping (Figure~\ref{fig:DataBinding} (a)). Thus, primitive 1 and 2 can be aligned into the same role.

\subsubsection{Encoding mapping}\label{sec:encodingmapping}
The previous two steps classify primitives according to two dimension: entity and role.
Thus, primitives of each data entity and their roles are determined.
We are able to answer \textbf{Q}\ref{qstn:composition}.
% 到此为止，我们已经已经知道每个实体是由哪些不同角色的元素组成，足够回答第一个问题
However, mappings between visual channels and data attributes are not determined.
% 我们继续以节点为例。
We continue to take node as for example.
% 为了检验一个属性究竟被编码在了哪些视觉通道上，我们通过shuffle所有节点的某个属性，观察视觉通道发生的变化。
We map one attribute to its related visual channels by first shuffling the attribute of all nodes and then observing the changes of visual channels of primitives.
% 变化可以被定义为，某个属性引起某些元素的某些视觉通道的变化。
One change can be defined as an \textit{attribute} causes changes in a \textit{visual channel} of a \textit{primitive}, which can be formalized as:
\begin{equation}
    change := \{ attribute, primitive, channel \}
\end{equation}
% 然后我们根据不同的primitive角色，对这些发生的变化进行合并。
We merge those changes according to the role of primitive.
It generates more comprehensive mappings between attributes and visual channels for different roles.
\textbf{Q}\ref{qstn:encodings} is solved.


To solve \textbf{Q}\ref{qstn:correlation}, we test correlations between attributes and visual channels.
Numerical, categorical, and list attributes are supported.
For visual channels, they are all numerical.
However, numerical data can be used as categorical data.
For example, numbers are usually used as labels.
Thus, for a numerical attribute, we should compare the number of unique attribute values and the number of data entities to determine whether it is numerical or categorical.
We set up a parameter $\alpha$, where the number of unique attribute values is less than $\alpha \%$ of the number of data entities, it is regarded as categorical.
We generate different correlations for different cases:
\begin{compactitem}
    \item The channel is categorical. The correlation is recorded and described by the channel's categories. For each category of the channel, we record value range of the attribute. % 我们记录了当视觉通道表达为这一类值的时候，属性的取值范围。
    If the value ranges of the attribute are intersected across different channel categories, we discard the correlation because it is ambiguous.
    \item Both the channel and the attribute numerical. We perform the Mann-Kendall test~\cite{10.2307/1907187, kendall1948rank} to analyze numerical to numerical mappings whether they are monotonic upward or downward.
    \item Other types of mappings are not supported yet.
\end{compactitem}


\subsubsection {Template-based Textualization}
Nodes are described at first, descriptions of links are same to nodes.
% 首先，我们需要描述数据实体被可视化为哪些视觉元素
We answer \textbf{Q}\ref{qstn:composition} with the primitives that compose a node.
Because the shape (\texttt{tagName}) of primitives may encode some attribtues, we first describe the number of primitives rather than describe the shape of primitives directly:
\textit{``A node consists of \$\{N\} different primitives''}. 

Then, different primitives in one node are categorized and discussed. 
For each primitive, there are several visual channels encoding attributes.
If its shape (\texttt{tagName}) encodes nothing, we describe its shape first: \textit{``The \$\{i\}th primitive is a \$\{\texttt{<tagName>}\}''}.
Then its visual channels are described respectively.
One channel may encode more than one attribute.
We describe them one by one with the template to solve \textbf{Q}\ref{qstn:encodings} and \textbf{Q}\ref{qstn:correlation}:
\textit{``Its \$\{channel\} encodes the attribute \$\{attribute\}''}.
When their correlation is monotonic, we will describe that:
\textit{``The greater \$\{attribute\} is, the greater/smaller its \$\{channel\} is''}.
When their correlation is categorical, we will describe them by the attribute's categories:
\textit{``When the attribute \$\{attribute\} is \$\{attribute\_category\}, its \$\{channel\} is \$\{ channel\_category \}''}.
If descriptions of two attributes within one channel are same, they can be merged.

And if the shape (\texttt{tagName}) of a primitive encodes some attributes, it is more complex.
We first describe its alternative shapes: 
``For the \$\{i\}th primitive, its \texttt{tagName} is varying among multiple shapes: \$\{ tagName1, tagName2, tagName3, ... \}''.
We describe the shape and its related attributes as categorical correlations.
For different shapes, we describe them one by one.


% \begin{algorithm}[!t]
%     \renewcommand\arraystretch{1.2}
%     \caption{ Encoding Textualization }
%     \label{alg:encoding}
%     \begin{algorithmic}[1]
%         \Require
%             $G=(V=\{v_1, v_2, ..., v_n\}, E=\{e_1, e_2, ..., e_n\})$: a graph;
%         \State Init role groups $RG=\varnothing$
%         \For {each primitive role $role$}
%             \State $sm\_role \gets $ the role with same encoding to $role$ in $RG$
%             \If {$sm\_role$ is not $\varnothing$}
%                 \State describe: $r$ has the same encodings with $sr$
%             \Else
%                 \State add $role$ into $RG$ 
%                 \If {$role$ is related to }
%                 \For {each visual channel $chan$ within $role$}
%                     \For {each attribute $attr$ that affects $chan$}
%                         \State describe: $chan$ encodes $attr$
%                         \State $corr \gets$ correlation between $attr$ and $chan$
%                         \If {$corr$ is monotonic upward}
%                             \State describe: the larger $attr$ is, the larger $chan$ is
%                         \ElsIf{$corr$ is monotonic downward}
%                             \State describe: the larger $attr$ is, the smaller $chan$ is
%                         \ElsIf{$corr$ is categorical}
%                             \For {each category $cate$ of $chan$}
%                                 \State $attr\_rg \gets $ the range of $attr$ with $cate$
%                                 \State describe: when $attr$ is $attr\_rg$, $chan$ is $cate$
%                             \EndFor
%                         \EndIf
%                     \EndFor
%                 \EndFor
%             \EndIf
%             \State add $r$ into $RG$
%         \EndFor
%         \State \Return $C$
%     \end{algorithmic}
% \end{algorithm}



% 在开始介绍算法之前，我们先列出我们对于通用情况的几点假设
% 1. 映射方式只跟数据分布相关（比如最大值最小值），当不改变数据的分布时，映射方式也不会改变；
% 2. 每个node都只会影响它自己相关的视觉元素的视觉编码，不会影响其他node；同样link也是（但节点可能会影响边）
% Before we introduce the technique, we list several assumptions that our technique requires:
% \begin{compactenum}
% \item Only the distribution of the data can influence the visual mapping scheme (e.g., the maximum value and the minimum value). 
% Only swapping two data entities will not cause any change of the visual mapping scheme.

% \item Swapping two nodes will not influence SVG elements related to other nodes; and so do links.
% Note that this assumption does not assume that swapping nodes will not influence links.

% \item Every nodes share a same encoding scheme and every links also share a same encoding scheme.
% \end{compactenum}
% % 我们认为这些情况是很常见的，适用于很多情况。我们的 gallery 也证明了我们的技术可以适用于很多case。
% Our gallery in the case study ({\color{text-highlight}Section~\ref{}}) suggests these assumptions are general in many cases.

% 首先，我们将svg视作一个树结构，其通过最广搜索算法或者最深搜索算法可以生成一个数组，称为svg数组。该数组只包含会产生视觉特征的svg元素：圆...等
% We regard the output SVG as a tree and use the Depth-First Search algorithm to generate a primitives list. 

% 我们首先交换任意节点对的属性。

% 首先我们获取节点的所有属性(除唯一标识符id之外)，遍历这些属性，对某个属性alpha：
% 我们通过调换两个节点（记作A和B，要求A和B的属性alpha不同）的属性alpha，记录svg数组中发生变化的项目（记作Set_{AB}）
% 在保留A的情况下，将B换成其他存在alpha属性不同的节点不断重复，对所有记录下来的项目变化求交集，即为A节点对应的视觉元素；
% 在此过程中，我们还能获取到属性A能够改变的视觉通道。
% 然后对于所有属性求出来的节点A对应的视觉元素的集合求并集，即为节点A对应的视觉元素；
% 对所有的边进行相同的步骤，找出每条边所对应的视觉元素。
% 从节点所对应的视觉元素中，减去边所对应的视觉元素。
% 最终我们就可以将数据绑定到视觉元素上了。
% 其中还有一种特殊情况，也就是只存在一个节点和A节点的数据不同。那么我们可以先把A节点换成该节点的数据。那么只要有超过两个节点的图数据，我们都能为A节点找到两个跟它数据不一样的节点了。
% 该过程的时间复杂度为O(k_n*N^2+k_e*M^2)
% 该过程为饱和式检查，保证了准确性；我们可以通过只交换A节点和B、C节点后求交集后就终止检查来将时间复杂度降低到O(k_n*N+k_e*M)，但会牺牲某些特殊情况下的准确性，比如.... 在实践过程中，我们可以通过调整参数x来平衡时间复杂度和精度之间的关系。

% 如果某个视觉通道，只有同时改变两个属性才能发生变化...这种情况就没法detect了


% 在上述的过程中，我们还获取到了数据属性是如何影响视觉通道的。
% 我们利用抽取的数据，来描述节点链接图的视觉编码方案：
% 1. 节点/链接的组成元素分别是什么？
% 2. 视觉通道的决定性因素（属性）是什么？
% 3. 视觉通道和其决定性因素的相关性如何？（正相关/负相关/类别相关..）

% 对于一个节点包含的多个视觉元素。我们对他们进行分组描述，分组的依据是视觉元素的编码方案是否一致。
% 同样的，如果不同的节点有不同的编码方案，我们也会对它们进行分组描述。


% 我们尝试从这几个方向增强该方法，并配合节点链接图的特性，帮助创作者更好的解释节点链接图中的编码方案。
% 我们发现，虽然 Deconstructing and Restyling D3 Visualizations 的方法只需要svg作为方法的输入，但它的svg是处于运行环境中的，也就是说，如果没有运行源代码，__data__属性也就没法绑定到对应的元素中。所以它隐式地依赖于可视化创作者的源代码。所以我们还可以使用其源代码用于分析。


%! 我们的方法的过程
% 我们对Deconstructing and Restyling D3 Visualizations进行了改进；主要从x方面进行：
% 作为该方法的补充，为了使数据绑定能够应用于非d3创建的代码，我们提出了一个检验方法，它将创建者创建的代码视作黑盒，通过修改输入的数据，检验输出的svg元素的变化来获取编码方案。
%? 这里假设了修改源数据，不会对代码造成影响，但实际上很多情况下，映射方式会根据数据本身进行更改，比如数据值的范围。可以放在discussion里面讨论一下。
% 下面的章节我们围绕着几个方面进行：
% 1. 如何为没有为没有进行数据绑定的svg，找到每个节点和链接对应的元素，以补充 Deconstructing and Restyling D3 Visualizations；
% 2. 新的视觉通道和属性之间的关联检验方式，防止出现多属性之间线性依赖以及复杂映射情形失效的情况；
% TODO下面都是围绕节点和链接展开，但我们的方法不仅仅能够解决节点链接图的可视化，也可以用用于其他类型的可视化形式。

%! 讲一下我们主要检测的基础视觉元素：

%! 1 首先对某个属性做出修改，但不修改数据分布，只调换数据顺序；查看哪个/些视觉通道发生了变化；找到那些不改变dom结构的属性（tagname和element数量）；
%!  对嵌套结构（数组/对象）进行说明：没有关系，等详细说明映射方式的时候再决定；
%! 2 过滤掉会对svg element的tagName和数量产生影响的属性，交换A节点和B节点的其余数据，观察哪些svg的视觉通道发生了变化；然后恢复数据；再交换A节点和C节点的其余数据，观察通道变化；取两次的交集的svg element，它们绑定的数据就是A节点；


% 我们首先提出了对该方法的增强算法，使该方法能够泛化到更通用的场景下。
% 因为我们方法目的是为创作者提供自动创建节点链接图描述的技术，所以我们假设了创作者的创作源码可以输入到我们的方法中用于提取信息。
% 虽然xxx等人的方法没有假设源代码的存在，但实际上，运行环境下，想要获取到svg元素的__data__属性，必定有运行中的JavaScript程序在背后支持，所以该工作也隐含了javascript的源码存在的假设。


\subsection{Layout}
Layouts of attributed graphs have been categorized into attribute-based layouts~\cite{} and topology-based layouts~\cite{} by Nobre et al.~\cite{DBLP:journals/cgf/NobreMSL19}.
We aim to detect whether the node-link diagram follows an attribute-based layout or a topology-based layouts.
To capture the position of each node, we compute a bounding box for each node's primitives detected in Section~\ref{sec:databinding}.
We take the centroid of the bounding box as the position of the node.
Pearson correlation coefficient is first computed to test whether the two dimensions of the Cartesian coordinate are correlated to any attribtue.
If the Pearson test suggests some attributes determine the position of a node,
% 然后我们像检验encoding和attribute的相关性一样检验坐标相关性。
we test correlations between positions and the attributes as same to the correlation test in Section~\ref{sec:encodingmapping}.

For topology-based layouts, we first perform a pre-study to test whether the euclidean distance between two nodes is influenced by their graph geodesic distance.