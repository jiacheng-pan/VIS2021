\section{\ApproachName}
%! overview

\subsection{Data Wrangling}
% 从表格型数据创建图数据时，最重要的就是建立节点之间的关系。
% 观众从节点链接图中所能获知的信息仅仅是某两个节点之间存在联系，但却不了解联系的内在含义。
% 一些论文已经对可能建立链接的情况进行了定义，
Several techniques~\cite{DBLP:journals/ivs/LiuNS14, DBLP:journals/ivs/HeerP14, DBLP:journals/tvcg/SrinivasanPEB18} about graph wrangling identify link construction as the crucial process and propose several linking conditions.
Ploceus~\cite{DBLP:journals/ivs/LiuNS14} and Orion~\cite{DBLP:journals/ivs/HeerP14} infer potential linking conditions by first constructing a linking graph and then searching valid linking paths. They are aimed at constructing links among multiple data tables by analyzing primary keys and foreign keys.
Graphiti~\cite{DBLP:journals/tvcg/SrinivasanPEB18} identifies potential linking conditions of a homogeneous graph by comparing different attributes.
% 如果多个表合并成一个表，前两者总结的条件可以被Graphiti提出的规则所覆盖
Because multiple tables can be merged into one data table with primary keys and foreign keys, Graphiti can cover the linking conditions identifying rules proposed by Ploceus and Orion. %? 这里mayby要用一张图解释一下
We reorganize the conditions proposed by these techniques into four categories:
\begin{compactenum}[\textbf{Cond.} 1.]
    \item Two nodes share a same value of a same attribute, e.g., linking two movies is published in the same year.
    \item Two nodes share at least one same common value of a same list attribute, e.g., linking two movies with one or more same actors.
    \item Two nodes share significantly close value of a same attribute where the significance is defined by the normalized difference.
    \item Two nodes share two values in the same bin of a same attribute where the bins are defined as quartiles.
\end{compactenum}
Hear, we regard sharing same topics of textual attributes as same as sharing same values of list attributes (Condition 2), because topics are often presented as a list attribute.

% 我们尝试从它们的反方向进行思考，也就是，当我们获取到了所有的链接的时候，推测这些链接是如何被构建的
Those works infer the potential linking conditions before all links are constructed. 
Whereas, our method runs in the opposite direction where all links have been constructed already.
% 针对某一条链接，可能有不止一种构建条件，我们取所有链接的构建条件的交集作为整个graph的构建条件。
We traverse all links to detect potential conditions for each link.
The intersection of all links' conditions are regarded as the entire graph's linking condition.

% 为了能够将这些condition填充到文本模板中，我们对condition的输出进行了formalize
At last, we formalize the condition as three aspects, and textualize the linking condition of the graph by filling templates. 
One condition can be defined as:
\begin{equation}
    \text{linking condition} := ( type, attribute, value )
\end{equation}
Four templates corresponds to four conditions according the $type$:

\begin{compactenum}[\textbf{Cond.} 1.]
    \item ``Two nodes are connected if their attributes $[{attribute}]$ are with a same value$\{: [{value}]?\}$''.
    \item ``Two nodes are connected if their attributes $[{attribute}]$ share an intersection$\{: [{value}]?\}$''.
    \item ``Two nodes are connected if their attributes $[{attribute}]$ are close, maybe with a difference less than $[{value}]$''.
    \item ``Two nodes are connected if their attributes $[{attribute}]$ are within the same bin$\{: [{value}]?\}$''.
\end{compactenum}

Where $[{attribute}]$ is the name of the attribute, $[{value}]$ is the value of the attribute, and $\{?\}$ means the included part is optional. 
For example, for Condition 2, two movies are connected because they share same actors Alice and Bob. 
The condition is represented as: $(\text{``Condition 2''}, \text{``actors''}, [\text{``Alice''}, \text{``Bob''}])$. 
Its corresponding statement is: ``Two nodes are connected if their attributes ``actors'' share an intersection: [``Alice'', ``Bob'']''. 
And there is an implication relation between conditions.
Some conditions are stronger than others.
For example, the condition $(\text{``Condition 2''}, \text{``actors''}, [\text{``Alice''}, \text{``Bob''}])$ is stronger than $(\text{``Condition 2''}, \text{``actors''}, [\text{``Alice''}])$ and $(\text{``Condition 2''}, \text{``actors''}, [arbitrary\text{ }value])$.
All the three conditions are regarded as individual conditions.

If a linking condition exists on both nodes with links and nodes without any link, it is regarded as a false condition and should be filtered out.
We describe our filtering strategy in~\ref{alg:conditions}.
After that, conditions are sorted, so that the highest ranked condition will be regard as the most possible condition.
First, all conditions are sorted by their frequency.
% 相同频率的条件，如果他们的type和attribute相同，那么根据
If two conditions with the same frequency have the same $type$ and $attribute$, they can be compared by their degree.
More stronger conditions are ranked higher than others.


% 一条边可能包含多个条件，不同边的条件之间可能有交集，可能没有交集。
% 我们需要一个策略来得到一个关于节点之间如何构建出关系的结论。
%! 解释一下算法
% 首先，对于所有没有边的节点对，找出所有可能的构建条件。
% 其次，对于某条边，它的构建条件和上述的构建条件之间找出差集。
% 最后，所有边的条件的合集属于边的构建条件；其中 频率最高的将被拿出来。



\begin{algorithm}[!t]
    \renewcommand\arraystretch{1.2}
    \caption{ Conditions filtering }
    \label{alg:conditions}
    \begin{algorithmic}[1]
        \Require
            $G=(V=\{v_1, v_2, ..., v_n\}, E=\{e_1, e_2, ..., e_n\})$: a graph;
        \Ensure
            $C$: conditions
        \State Init conditions $C=\varnothing$, false conditions $FC=\varnothing$
        \For {each node pair $(v_i, v_j)$}
            \If {$(v_i, v_j)$ is not a link}
                \State $C_{tmp} \gets$ all conditions that can link $(v_i, v_j)$
                \State merge $FC$ with $C_{tmp}$
            \EndIf
        \EndFor
        \For {each link $e_i$}
            \State $C_{tmp} \gets$ all conditions that can construct link $e_i$
            \For {each condition $c$ in $C_{tmp}$}
                \If {$c$ in $FC$}
                    \State remove $c$ from $C_{tmp}$
                \EndIf
            \EndFor
            \State merge $C$ with $C_{tmp}$
        \EndFor
        \State \Return $C$
    \end{algorithmic}
\end{algorithm}


\subsection{Visual Encoding}
%! 首先说明目标是什么
% 节点链接图，顾名思义，包含两部分：节点和链接。对其进行编码也主要聚焦于这两部分

% Node-link diagram basically consists of two pars: nodes and links, as its name implies.
%! 讲一些背景，svg相关的；
%! 讲以往工作是怎么做的？
%! 节点链接图该怎么进行分析？
%! 以往工作的不足




% 为了能够向观众解释节点链接图的编码是什么，我们希望通过分析创作者使用的图数据，创作者编写的代码，得到他使用的编码方案。我们通过三个层次来叙述节点链接图的编码方案：
% 1. 节点/链接的组成元素分别是什么？
% 2. 视觉通道的决定性因素（属性）是什么？
% 3. 视觉通道和其决定性因素的相关性如何？（正相关/负相关/类别相关..）


%! Deconstructing and Restyling D3 Visualizations 的一些不足之处
%! 1. __data__的依赖
%! 2. 映射关系的检验
%TODO: 可能还存在一些不足，在实现的时候可以被发现
% Deconstructing and Restyling D3 Visualizations 对于解决上述问题提出了一些很有见解的解决方法。但它也有一些不足之处。
% 1. 其需要创作者使用d3的数据绑定，才能发挥__data__的作用；使用其他工具，或者未将数据绑定到元素上时则无法使用该方法；
% 2. 其检验视觉通道和属性之间的关联，是通过检验属性和视觉通道之间是否存在线性映射或者类别性映射。在以下两种情况下该方法会失效：
%   2.1 如果不同的数据属性之间相互是线性相关的，那么该方法就无法真正确定是哪一种属性决定了视觉通道；
%   2.2 其检验的映射过于简单，复杂情形下无法得到相互关联的结论；

% 我们尝试从这几个方向增强该方法，并配合节点链接图的特性，帮助创作者更好的解释节点链接图中的编码方案。
% 我们发现，虽然 Deconstructing and Restyling D3 Visualizations 的方法只需要svg作为方法的输入，但它的svg是处于运行环境中的，也就是说，如果没有运行源代码，__data__属性也就没法绑定到对应的元素中。所以它隐式地依赖于可视化创作者的源代码。所以我们还可以使用其源代码用于分析。


%! 我们的方法的过程
% 我们对Deconstructing and Restyling D3 Visualizations进行了改进；主要从x方面进行：
% 作为该方法的补充，为了使数据绑定能够应用于非d3创建的代码，我们提出了一个检验方法，它将创建者创建的代码视作黑盒，通过修改输入的数据，检验输出的svg元素的变化来获取编码方案。
%? 这里假设了修改源数据，不会对代码造成影响，但实际上很多情况下，映射方式会根据数据本身进行更改，比如数据值的范围。可以放在discussion里面讨论一下。
% 下面的章节我们围绕着几个方面进行：
% 1. 如何为没有为没有进行数据绑定的svg，找到每个节点和链接对应的元素，以补充 Deconstructing and Restyling D3 Visualizations；
% 2. 新的视觉通道和属性之间的关联检验方式，防止出现多属性之间线性依赖以及复杂映射情形失效的情况；
% TODO下面都是围绕节点和链接展开，但我们的方法不仅仅能够解决节点链接图的可视化，也可以用用于其他类型的可视化形式。

%! 讲一下我们主要检测的基础视觉元素：

%! 1 首先对某个属性做出修改，但不修改数据分布，只调换数据顺序；查看哪个/些视觉通道发生了变化；找到那些不改变dom结构的属性（tagname和element数量）；
%!  对嵌套结构（数组/对象）进行说明：没有关系，等详细说明映射方式的时候再决定；
%! 2 过滤掉会对svg element的tagName和数量产生影响的属性，交换A节点和B节点的其余数据，观察哪些svg的视觉通道发生了变化；然后恢复数据；再交换A节点和C节点的其余数据，观察通道变化；取两次的交集的svg element，它们绑定的数据就是A节点；

\subsection{Layout}

\subsection{Interview \& Iterative Design}

\subsection{Understanding Visual Clutter}